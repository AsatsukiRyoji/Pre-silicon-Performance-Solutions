##################################################
##All _b(and)w(idth) default unit is Bytes
##!!ALERT: no upper-case in the name can be used, either it will miss
##################################################
[PARAMETER]
threads/wave = 64
bytes/sgpr = 4
bytes/vgpr = 4
##[31:8(base)][7:0(offset)]
bytes/addr_ds = 4
##16B of every dispatching of TG
cp_dispatch_tg_payload = 16
[CONFIG]
cp/core = 1
se/core = 4
cu/se = 8
spi/se = 1
sq/cu = 1
sp/cu = 2
simd16/sp = 2
lds/cu = 1
ta/cu = 1
td/cu = 1
tcp/cu = 1
cmd_bit/vmem = 184
#4 simd16 in one cu, 2 of them is one sp
simd_width = 16
#CP
cp_pipes = 4
cp_pipe_queues = 8
## one bus per pipe
cp_csdata_bus = 4
cp_csdata_data_bw = 4
#SPI
##spi to vgpr serial bus, two buses connect to sp0 and sp1, 
#can work concurrently
spi_vdata_bus = 2
spi_vdata_data_bw = 128
#spi to sgpr of sq. Serial bus to all CU
spi_sdata_bus = 1
spi_sdata_data_bw = 16
#SQ
sq_ta_cmd_bus = 1
##data field width
sq_ta_cmd_data_bw = 46
#LDS
lds_banks = 32
lds_ds_bw = 128
sp_lds_idx_data_bus = 2
sp_lds_idx_data_data_bw = 64
lds_sp_idx_data_bus = 2
lds_sp_idx_data_data_bw = 64
#TD
td_sp_data_bus = 1
td_sp_data_data_bw = 64
tcp_td_data_bus = 1
tcp_td_data_data_bw = 64
#TA
sp_ta_addr_bus = 1
sp_ta_addr_data_bw = 64
##addr_hi is for flat offset, totally 272 bits, but 16 of it is symbol of 64/32.
sp_ta_addr_addr_hi_bw = 32
sp_ta_data_bus = 1
sp_ta_data_data_bw = 64
ta_tc_cmd_bus = 1
ta_tc_cmd_data_bw = 46
ta_tc_addr_bus = 1
##ta_tc_addr_data has address information of 4 pixels. Every pixel occupies 52 bits.
##u0(|1|2|3)_ta_tc_(corrd_buffer_msb|coord_incr[1:0]|mipmip_level[3:0]|coord_top_left[40:0]|_valid[3:0])
##To buffer and flat, coord_top_left is address, if address is coalesced, it means 4 address to TCP, 
##If not coalesced, it contains only 1 address to TCP
ta_tc_addr_data_bw = 20.5
ta_tcp_data_bus = 1
ta_tcp_data_data_bw = 64
#TCP
tcp_tagrams = 4
tcp_cachelines_per_tagram = 64
tcp_cacheline_size = 512
[CAPACITY]
##################################################
##CAPACITY is the INTERNAL performance index of a block,
##It generally is given by Architect.
##Unit is '[tg/wave/inst]/cycle'. 
##For peak test, theory result is the /cycle dealing 
##rate on wave-scale at bottleneck block. 
##Naming rule: 1)<action>_<action payload>
##If the capacity is limited by data bus, it will 
##be deducted through 'config', but if it's a command 
##and/or internal limitation, like spi-sq-cmd use 'msg[3:0]' 
##to send 'new_wave', it will be listed here since 
##it's limited by block internal dealing capacity
##################################################
#CP
##At max., CP can cut one TG per cycle to issue to one SPI
##unit : threadgroup/cycle
cp_adc_prepare_tg = 1
#SPI
#launch 1 wave to 1 sq per 4 cycles
#spi-sq-cmd, msg 0 is new_wave
spi_alloc_w64 = 0.25
# per SE will get and use baton 4 cycles
spi_use_baton = 4
#initialize 1 vgpr(64thread*1DW) per vdata bus 4 cycles to one SP, 2 buses can work concurrently
#init_vgpr = 0.25
#initialize 4 sgpr(4DW) per sdata bus per cycle
#init_sgpr = 4
#SQ inst/cycle
##Every cycle issue one to one simd-16
sq_pick_valu = 1
sq_pick_salu = 1
sq_pick_lds_idx = 0.25
sq_pick_lds_atomic = 0.25
##command to TA
# ID-EX pick rate in SQ internal
# the pick rate in internal SQ internal from IB to EX pipeline
sq_id_pick_vmem = 1
##command to SQC
sq_pick_smem = 1
sq_pick_branch = 1
sq_exec_salu = 1
#SIMD-16
#fullrate: 16 threads/cycle
#unit: threads/cycle
simd_exec_vop8_normal = 16
simd_exec_vop16_normal = 16
simd_exec_vop16_half_rate = 8
# when edc enable the fullrate of fma_f16 and add_i16 is 8 thread/cycle 
simd_exec_vop16_normal_edc_on = 8
simd_exec_vop16_normal_edc_off = 16
simd_exec_vop32_normal_edc_on = 16
simd_exec_vop32_normal_edc_off = 16
#simd_exec_vop16_pk = 32
simd_exec_vop16_trans = 4
simd_exec_vop32_normal = 16
simd_exec_vop32_normalx4 = 4
simd_exec_vop32_half_rate = 8
simd_exec_vop32_comparation = 16
simd_exec_vop32_division = 16
simd_exec_vop32_trans = 4
#simd_exec_vop64_normal = 8
#The normal vop64 like v_fma_f64 inst fullrate should be 16 threads/cycle and confirm with yangyu
simd_exec_vop64_normal = 16
simd_exec_vop64_trans = 4
simd_exec_vop64_dp4xon = 16
##lds_latency
lds_read_b32_latency = 38
lds_write_b64_latency = 45
lds_and_b32_latency = 42
##gds_latency
gds_read_b32_latency = 222
gds_write_b128_latency = 487
gds_add_u64_latency = 456

[INTERFACE]
cpspi_cadata_sim_vec = cpc_se\dspi_csdata\d_sim.vec
spisq_cmd_sim_vec = se\d__spi_sq0_cmd_sim.vec
spisq_sdata_sim_vec = se\d__spi_sq\d_sdata_sim.vec
spisp_vdata_sim_vec = se\d__spi_sp\d_vdata\d_sim.vec
sqspi_msg_sim_vec = se\d__sq0_spi_msg_sim.vec
sqsp_simd_cmd_vec = se\d+__sh\d+__sq\d+_sp\d+_simd\d+_cmd_sim.vec
sqsp_simd_src_d_vec = se\d+__sh\d+__sq\d+_sp\d+_simd\d+_src_d_sim.vec
sqsp_simd_src_c_vec = se\d+__sh\d+__sq\d+_sp\d+_simd\d+_src_c_sim.vec
sqsp_excp_vec = se\d+__sh\d+__sp\d+_sq\d+_excp_sim.vec
sqta_cmd_vec = se\d__sq_sh\d+ta\d+_cmd_sim.vec
ldssp_read_sim_vec = se\d+__sh\d+__lds\d+_sp\d+_read_sim.vec
splds_idx_sim_vec = se\d+__sh\d+__sp\d+_lds\d+_idx_sim.vec
sqlds_idx_vec = se\d+__sh\d+__sq\d+_lds\d+_idx_sim.vec
ldssq_idxdone_vec = se\d+__sh\d+__lds\d+_sq\d+_idxdone_sim.vec
tatc_addr_sim_vec = ta\d+_tc_addr_sim.vec
tctd_data_sim_vec = tc_td\d*_data_sim.vec
tdsp_data_sim_vec = se\d__sh0td\d*_sp_data_sim.vec
tcea_rdreq_sim_vec = tc\d+_ea\d+_rdreq_sim.vec
tcea_wrreq_sim_vec = tc\d+_ea\d+_wrreq_sim.vec
eatc_rdret_sim_vec = ea\d+_tc\d+_rdret_sim.vec
eatc_wrret_sim_vec = ea\d+_tc\d+_wrret_sim.vec
tcptcr_req_sim_vec = tcp\d+_tcr_req_sim.vec
tcrtcp_ret_sim_vec = tcr_tcp\d+_ret_sim.vec
sxgds_data_sim_vec = sx\d+_gds_vdata0_sim.vec
gdstd_data_sim_vec = gds_se\d+td0_data0_sim.vec 
sxgds_expcmd_sim_vec = sx\d+_gds_expcmd0_sim.vec
gdstd_rddone_sim_vec = gds_se\d+td0_rddone0_sim.vec
#latency
tdsq_rddone_vec = se\d+__sh\d+td\d+_sq_rddone_sim.vec
#sqc latency
sqsqc_data_req_sim_vec = se\d+__sh\d+__sq\d+_sqc\d+_data_req_sim.vec
sqsqc_inst_req_sim_vec = se\d+__sh\d+__sq\d+_sqc\d+_inst_req_sim.vec
sqcsq_data_ret_sim_vec = se\d+__sh\d+__sqc\d+_sq\d+_data_ret_sim.vec
sqcsq_inst_ret_sim_vec = se\d+__sh\d+__sqc\d+_sq\d+_inst_ret_sim.vec
sqctc_req_sim_vec = se\d+sh\d+sqc\d+_tc_req_sim.vec
tcsqc_ret_sim_vec = tc_se\d+sh\d+sqc\d+_ret_sim.vec
[PATTERN]
cpspi_cadata_ptn = CPC_SE\dSPI_csdata\d
#[valid clken msg == 1 1 0]: new wave
spisq_launch_ptn = se\d__SPI_SQ0_cmd\s1\s1\s\w+\s\w+\s0
spisq_sdata_ptn = se\d__SPI_SQ\d_sdata
spisp_vdata_ptn = se\d__SPI_SP\d_vdata\d
#[valid msg == 1 0]: wave done
sqspi_done_ptn = se\d__SQ0_SPI_msg\s1\s00\s
sqsp_simd_cmd_ptn = se\d+__sh\d+__SQ\d+_SP\d+_simd\d+_cmd
sqsp_simd_src_d_ptn = se\d+__sh\d+__SQ\d+_SP\d+_simd\d+_src_d
sqsp_simd_src_c_ptn = se\d+__sh\d+__SQ\d+_SP\d+_simd\d+_src_c
sqsp_excp_ptn = se\d+__sh\d+__SP\d+_SQ\d+_excp
sqta_cmd_ptn = se\d+__SQ_SH\d+TA\d+_cmd
ldssp_read_ptn = se\d+__sh\d+__LDS\d+_SP\d+_read
splds_idx_ptn = se\d+__sh\d+__SP\d+_LDS\d+_idx
sqlds_idx_ptn = se\d+__sh\d+__SQ\d+_LDS\d+_idx
ldssq_idxdone_ptn = se\d+__sh\d+__LDS\d+_SQ\d+_idxdone
#[send return_ack == 1 0]: valid read data
tctd_vld_data = TC_TD\d*_data\s1\s0
#[valid == 1]: valid data
tatc_addr_ptn = TA\d+_TC_addr
tdsp_vld_data = se\d__SH0TD\d*_SP_data\s1
tcea_rdreq_ptn = TC\d+_EA\d+_rdreq\s\d\s\d(\s\w+)+
eatc_rdret_ptn = EA\d+_TC\d+_rdret\s\d\s\d(\s\w+)+
tcea_wrreq_ptn = TC\d+_EA\d+_wrreq\s\d\s\d(\s\w+)+
eatc_wrret_ptn = EA\d+_TC\d+_wrret\s\d\s\d(\s\w+)+
tdsp_data_ptn = se\d+__SH0TD\d+_SP_data(\s+\w+)+
tcptcr_req_ptn = TCP\d+_TCR_req(\s+\w+)+
tcptcr_req_sim_ptn = TCP\d+_TCR_req
tcrtcp_ret_sim_ptn = TCR_TCP\d+_ret
sxgds_data_ptn = SX\d+_GDS_vdata0(\s+\w+)+
sxgds_expcmd_sim_ptn = SX\d+_GDS_expcmd\d+
gdstd_rddone_sim_ptn = GDS_SE\d+TD\d+_rddone\d+
#latency
tdsq_rddone_ptn = se\d+__SH\d+TD\d+_SQ_rddone
#sqc latency
sqsqc_data_req_ptn = se\d+__sh\d+__sq\d+_sqc\d+_data_req
sqsqc_inst_req_ptn = se\d+__sh\d+__sq\d+_sqc\d+_inst_req
sqcsq_data_ret_ptn = se\d+__sh\d+__sqc\d+_sq\d+_data_ret
sqcsq_inst_ret_ptn = se\d+__sh\d+__sqc\d+_sq\d+_inst_ret
sqctc_req_ptn = se\d+sh\d+sqc\d+_tc_req
tcsqc_ret_ptn = tc_se\d+sh\d+sqc\d+_ret

