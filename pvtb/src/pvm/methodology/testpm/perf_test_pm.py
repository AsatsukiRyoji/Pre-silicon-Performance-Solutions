#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Performance Test PerfModel basic
@author: Li Lizhao
"""
import os,sys,re
from pandas import DataFrame as DF
import pandas as pd
import pdb

cdir = os.path.dirname(os.path.realpath(__file__)) + '/'
sys.path.append(cdir+'../')

import utility.util as util
from theory.core_performance_theory import ComputeCoreTheory as CCT
from measure.core_performance_measure import ComputeCoreMeasure as CCM
from check.core_performance_check import ComputeCoreCheck as CCC
from check.core_performance_check import check_meas_map

dv_dir = cdir + '/../../cache/'
testpm_cfg_d = {
    'default'          : {
        'dv'            : cdir+'/../../test.dv'
        ,'test_ptn'     : "perf_test"
        ,'test_param_l' : []
        ,'warmup'       : 0
    }
}

class PerfTestPM:
    
    def __init__(self):
        self.theo, self.meas, self.chk_df = DF(), DF(), DF()
        self.test_info_df = DF()
        ##XXX:test_cfg MUST be overwritten in inherited class
        self.test_cfg = testpm_cfg_d['default']
        #self.log = util.PMLog(name='perf_test_pm', path=cdir)
        pass

    def theory(self, desc, test=None, gui_en=False, **kw):
        """Performance Test Theory
        :test: reg-ex of test name, str
        """
        self.test_info_df = util.acquire_all_tests(self.test_cfg, test)

    def measure(self, desc, algo, edir='./', test=None, gui_en=False, **kw):
        """Test Measure
        :algo: [], or str list "[]", or single str
        :edir: Support relative dir './' and abs. dir in single test mode and batch mode
        :test: reg-ex of test name, str
        """
        edir = edir + '/' if not edir.endswith('/') else edir
        edir = os.getcwd() + '/' if edir == './' else edir
        ##In single mode, the dir could be under test's out
        edir = edir + '../' if edir.endswith(test+'/') else edir

        if type(algo) == str:
            try: algo_l = eval(algo)  #If it's a str([])
            except: algo_l = [algo]

        meta_df = util.acquire_all_tests(self.test_cfg, test, 'measure')
        meta_df['edir'] = meta_df['name'].apply(lambda x: edir+x+'/')
        ##remove invalid out directory is generated by test.dv
        meta_df['edir'] = meta_df['edir'].apply(lambda x: x if os.path.isdir(x) else None)
        meta_df['warmup'] = self.test_cfg['warmup']
        meta_df['algo'] = ','.join(algo_l)
        ccm = CCM(desc, meta_df)
        _df = ccm.get_measure()
        _df = _df.drop(['edir', 'warmup'], axis=1)
        out = [DF()]
        _df.T.apply(util.split_se_2df, args=(',', out)) 
        self.meas = self.meas.append(out[0], ignore_index=True)
        ##modify channel_risk
        self.meas.loc[self.meas['channel_risk']=='False','channel_risk'] = 'No_Risk'
        self.meas.loc[self.meas['channel_risk']=='True','channel_risk'] = 'Have_Risk'
        if gui_en:
            gui = util.PMGui()
            gui.run([self.meas])
        #print(self.meas)
        #return self.meas

    def check(self, desc, edir, test, gui_en=False, **kw):
        '''
        :test: reg-ex of test name, str. Not like theory and measure, it's necessary.
        '''
        edir = edir + '/' if not edir.endswith('/') else edir
        edir = os.getcwd() + '/' if edir == './' else edir
        edir = edir + '../' if edir.endswith(test+'/') else edir
        ##In single mode, the dir could be under test's out
        meth_desc = util.get_cfg_f(cdir+'../methodology.cfg')
        #NOTE: self points to the derived class which using 'super()' calling it's base class
        is_ref = False
        is_latency = False
        algo = None
        if 'ooo' in test or 'from' in test or 'burst'  in test or ('structure_buffer' in test and 'hitTCP' in test) or ('atomic_cmpswap' in test and 'structure_buffer' in test):
            self.theory(desc, test, rdir=edir)
            is_ref = True
            if 'burst' in test and 'buffer' in test: 
                algo = 'tcctcr_data'
            elif 'burst' in test and 'store' in test:
                algo = 'tcrtcc_data'
            else:
                algo = 'wavelifetime'
        else:
            self.theory(desc, test)

        if 'latency_ds' in test:
            is_latency = True
        chk_df = self.theo.reindex(columns=meth_desc['test_check_col'].split(','))
        ##'test_check_col': 'name,check,ratio,theory,measure,unit,bottleneck,formula'
        tests = list(chk_df['name'])
        for i,b in enumerate(list(self.theo['bottleneck'])):
            self.measure(desc, check_meas_map.get(b, check_meas_map['default']), edir, tests[i])
            #[XXX]The 'name' is updated again here per the same list, if the test output
            #couldn't be found under edir, the value becomes 'TBD'        
        chk_df.update(self.meas)
        ccc = CCC(desc, chk_df)
        chk_df = ccc.get_chk(is_ref, algo, is_latency)
        self.chk_df = chk_df
        if kw.get('func_result') == 'func faild':
            self.chk_df['check'] = 'func faild'
        if gui_en:
            gui = util.PMGui()
            gui.run([self.chk_df])
        #return self.chk_df

if __name__=='__main__':
    opt = util.option_parser()
    ptpm = PerfTestPM()
    if opt.func == 'theory':
        ptpm.theory(opt.desc, opt.test, opt.gui_en)
    elif opt.func == 'measure':
        ptpm.measure(opt.desc, opt.algo, opt.edir, opt.test, opt.gui_en)
    elif opt.func == 'check':
        ptpm.check(opt.desc, opt.edir, opt.test, opt.gui_en)
        
    else:
        print('NYI')
        sys.exit()


